#+TITLE: Static Analysis: List 3
#+AUTHOR: Marcos Vinicius Moreira Santos - 2018054982
#+DATE: 12-03-2022
#+LATEX_HEADER: \usepackage{flowchart}
#+LATEX_HEADER: \usepackage{tikz}
#+LATEX_HEADER: \usetikzlibrary{arrows, shapes, positioning}
#+LATEX_HEADER: \usepackage[clean]{svg}
#+OPTIONS: toc:nil        (no default TOC at all)

#+BEGIN_abstract
This document contain my answers for the questions at https://homepages.dcc.ufmg.br/~fernando/classes/dcc888/ementa/hw/IntroDataFlow.pdf for the Static Analysis course at UFMG.
#+END_abstract


***** 
lets name the nodes on the control flow graph:

p_0: x = 1

p_1: y = read()

p_2: (y > 0)?

p_3: x = 2

p_4: print(x)

p_5: x = x + 1

p_6: y = y - 1

p_7: goto


Applying the equations IN(p_i) = (OUT(p_i) \ {v}) \cup vars(E), OUT(p_i) = \wbigcup IN(p_s) for p_s \in succ(p_i) for nodes p_i of type v = E, and IN(p_i) = (OUT(p_i)) \cup vars(E), OUT(p_i) = \wbigcup IN(p_s) for p_s \in succ(p_i) for nodes p_i of type E we end up with:

IN(p_0) = OUT(p_0) \ {x}

OUT(p_0) = IN(p_1)

IN(p_1) = OUT(p_1) \ {y}

OUT(p_1) = IN(p_2)

IN(p_2) = OUT(p_2) \cup {y}

OUT(p_2) = IN(p_3) \cup IN(p_5) \cup IN(p_7)

IN(p_3) = OUT(p_3) \ {x}

OUT(p_3) = IN(p_4)

IN(p_4) = OUT(p_4)

OUT(p_4) = {}

IN(p_5) = (OUT(p_5) \ {x}) \cup {x}

OUT(p_5) = IN(p_6)

IN(p_6) = (OUT(p_6) \ {y}) \cup {y}

OUT(p_6) = IN(p_7)

IN(p_7) = OUT(p_7)

OUT(p_7) = IN(p_2)

***** 
A program point p: v = E have IN sets and OUT sets, the variable 'v' is dead if 'v' \notin OUT(p), what signals that that variable in not going to be used again, in fact, all variables defined before the program point p that are not in OUT(p) are dead at that point, from this observation we have:

OUT_{quasi-dead}(p) = IN_{quasi-dead}(p) \cup (({v} \cup vars(E)) \ (OUT(p) \cap (vars(E) \cup {v})))

X, {v} \subseteq X, X \subseteq IN(p), X \nsubseteq OUT(p)

IN_{quasi-dead}(p) = \cup IN_{quasi-dead}(p_p), p_p \in pred(p)

Where pred(p) is the parent program points of p, OUT(p) and IN(p) are the set of alive variables right after and right before program point p. Those equations say that IN_{quasi-dead}(p) is all variables quasi-dead before p and that OUT_{quasi-dead}(p) are all variables used to compute v given that v is dead. 

***** 3
Lets define a context that assign each variable a subset of the set {\plus, \minus, 0}, the context can be seen as a set of the form {a:{\plus, 0}, b:{\minus, 0}} for example, lets use C to denote the context, operations over sets are allowed when using only the symbol values inside other sets, for instance C\{a} removes the symbol and the assignment of variable 'a' from C. We also define a operation C[a] that returns the assigned subset of {\plus, \minus, 0} of 'a' inside C;

We can then define:

(a) p: a = n, n \in $N$

IN_{sign}(p) = OUT_{sign}(p) \ { a : {\plus, 0} }

OUT_{sign}(p) = (\cup IN_{sign}(p_s)) \cup { a: {\plus, 0} }, p_s \in succ(p)

(b) p: a = b

IN_{sign}(p) = OUT_{sign} \ { a : sign(b) }

OUT_{sign}(p) = (\cup IN_{sign}(p_s)) \cup { a: sign(b) }, p_s \in succ(p)

(c) p: a = b - c

IN_{sign}(p) = OUT_{sign} \ { a : sign(b - c) } \cup {b: sign(b), c: sign(c)}

OUT_{sign}(p) = (\cup IN_{sign}(p_s)) \cup { a: sign(b - c) }, p_s \in succ(p)

where sign(b - c) = switch(a and b)
  case sign(b) = {\plus, 0} and sign(c, {\plus, 0}) then {\plus, \minus, 0},
  case sign(b) = {\minus, 0} and sign(c, {\plus, 0}) then {\minus, 0},
  case sign(b) = {\plus, 0} and sign(c, {\minus, 0}) then {\plus, 0},
  case sign(b) = {\minus, 0} and sign(c, {\minus, 0}) then {\plus, \minus, 0}

(d) p: a = b + c

IN_{sign}(p) = OUT_{sign}(p) \ { a : sign(b + c) } \cup {b: sign(b), c: sign(c)}

OUT_{sign}(p) = (\cup IN_{sign}(p_s)) \cup { a: sign(b + c) }, p_s \in succ(p)

\text{
where sign(b + c) = switch(sign(b) and sign(c))
  case {\plus, 0} and {\plus, 0} then {\plus, 0},
  case {\minus, 0} and {\plus, 0} then {\plus, \minus, 0},
  case {\plus, 0} and {\minus, 0} then {\plus, \minus, 0},
  case {\minus, 0} and {\minus, 0} then {\minus, 0}
}
(e) a = b \times c

IN_{sign}(p) = OUT_{sign}(p) \ { a : sign(b \times c) } \cup {b: sign(b), c: sign(c)}

OUT_{sign}(p) = (\cup IN_{sign}(p_s)) \cup { a: sign(b \times c) }, p_s \in succ(p)

sign(b \times c) = switch(sign(b) and sign(c))
  case {\plus, 0} and {\plus, 0} then {\plus, 0},
  case {\minus, 0} and {\plus, 0} then {\minus, 0},
  case {\plus, 0} and {\minus, 0} then {\minus, 0},
  case {\minus, 0} and {\minus, 0} then {\plus, 0}

(f) p: if a goto L_i

IN_{sign}(p) = OUT_{sign}(p)

OUT_{sign}(p) = \cup IN_{sign}(p_s), p_s \in succ(p)

(g) p: goto L_i

IN_{sign}(p) = OUT_{sign}(p)

OUT_{sign}(p) = \cup IN_{sign}(p_s), p_s \in succ(p)

(h) p: print a

IN_{sign}(p) = OUT_{sign}(p)

OUT_{sign}(p) = \cup IN_{sign}(p_s), p_s \in succ(p)

***** 

p_0: a = 0

p_1: p = a - N

p_2: if p goto L_1

p_3: print p

p_4: b = 0

p_5: a = a + b

p_6: goto L_2

then:

IN_{sign}(p_0) = {}

OUT_{sign}(p_0) = { a: {\plus, 0} }

IN_{sign}(p_1) = { a: {\plus, 0}, N: {\plus,\minus, 0} }

OUT_{sign}(p_1) = {a: {\plus, 0}, p: {\plus, \minus, 0}}

IN_{sign}(p_2) = {a: {\plus, 0}, p: {\plus, \minus, 0}}

OUT_{sign}(p_2) = {a: {\plus, 0}, p: {\plus, \minus, 0}}

IN_{sign}(p_3) = { p : {\plus, \minus, 0} }

OUT_{sign}(p_3) = {}

IN_{sign}(p_4) = {a: {\plus, 0}}

OUT_{sign}(p_4) = {a: {\plus, 0}, b: {\plus, 0}}

IN_{sign}(p_5) = {a: {\plus, 0}, b: {\plus, 0}}

OUT_{sign}(p_5) = {}

IN_{sign}(p_6) = {}

OUT_{sign}(p_6) = {}